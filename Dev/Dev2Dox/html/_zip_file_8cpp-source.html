<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>GameCode: d:/Projects/GameCodev2.2/Source/ResourceCache/ZipFile.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.3 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">d:</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000001.html">Projects</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000002.html">GameCodev2.2</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000003.html">Source</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000013.html">ResourceCache</a></div>
<h1>ZipFile.cpp</h1><a href="_zip_file_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//========================================================================</span>
<a name="l00002"></a>00002 <span class="comment">// ZipFile.cpp : API to use Zip files</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// Part of the GameCode2 Application</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// GameCode2 is the sample application that encapsulates much of the source code</span>
<a name="l00007"></a>00007 <span class="comment">// discussed in "Game Coding Complete - 2nd Edition" by Mike McShaffry, published by</span>
<a name="l00008"></a>00008 <span class="comment">// Paraglyph Press. ISBN: 1-932111-91-3</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">// If this source code has found it's way to you, and you think it has helped you</span>
<a name="l00011"></a>00011 <span class="comment">// in any way, do the author a favor and buy a new copy of the book - there are </span>
<a name="l00012"></a>00012 <span class="comment">// detailed explanations in it that compliment this code well. Buy a copy at Amazon.com</span>
<a name="l00013"></a>00013 <span class="comment">// by clicking here: http://www.amazon.com/exec/obidos/ASIN/1932111913/gamecodecompl-20/</span>
<a name="l00014"></a>00014 <span class="comment">//</span>
<a name="l00015"></a>00015 <span class="comment">// There's also a companion web site at http://www.mcshaffry.com/GameCode/portal.php</span>
<a name="l00016"></a>00016 <span class="comment">//</span>
<a name="l00017"></a>00017 <span class="comment">// (c) Copyright 2005 Michael L. McShaffry</span>
<a name="l00018"></a>00018 <span class="comment">//</span>
<a name="l00019"></a>00019 <span class="comment">// This work is licensed under the Creative Commons Attribution-ShareAlike License. </span>
<a name="l00020"></a>00020 <span class="comment">// To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/1.0/ </span>
<a name="l00021"></a>00021 <span class="comment">// or send a letter to:</span>
<a name="l00022"></a>00022 <span class="comment">//      Creative Commons</span>
<a name="l00023"></a>00023 <span class="comment">//      559 Nathan Abbott Way</span>
<a name="l00024"></a>00024 <span class="comment">//      Stanford, California 94305, USA.</span>
<a name="l00025"></a>00025 <span class="comment">//</span>
<a name="l00026"></a>00026 <span class="comment">//========================================================================</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">//========================================================================</span>
<a name="l00029"></a>00029 <span class="comment">//  Content References in Game Coding Complete 2nd Edition</span>
<a name="l00030"></a>00030 <span class="comment">// </span>
<a name="l00031"></a>00031 <span class="comment">// class CZipFile - Chapter 7, page 202</span>
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00035"></a>00035 <span class="comment">// File:        ZipFile.cpp</span>
<a name="l00036"></a>00036 <span class="comment">//</span>
<a name="l00037"></a>00037 <span class="comment">// Purpose:     The implementation of a quick'n dirty ZIP file reader class.</span>
<a name="l00038"></a>00038 <span class="comment">//              Original code written by Javier Arevalo. </span>
<a name="l00039"></a>00039 <span class="comment">//              Get zlib from http://www.cdrom.com/pub/infozip/zlib/</span>
<a name="l00040"></a>00040 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#include "<a class="code" href="_game_code_std_8h.html">GameCodeStd.h</a>"</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#include "<a class="code" href="_zip_file_8h.html">ZipFile.h</a>"</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include "<a class="code" href="zlib_8h.html">zlib\zlib.h</a>"</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;<a class="code" href="_string_8h.html">string.h</a>&gt;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00049"></a>00049 <span class="comment">// Basic types.</span>
<a name="l00050"></a>00050 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00051"></a><a class="code" href="_zip_file_8cpp.html#a0">00051</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="_zip_file_8cpp.html#a0">dword</a>;
<a name="l00052"></a><a class="code" href="_zip_file_8cpp.html#a1">00052</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="_zip_file_8cpp.html#a1">word</a>;
<a name="l00053"></a><a class="code" href="_zip_file_8cpp.html#a2">00053</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="_zip_file_8cpp.html#a2">byte</a>;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00056"></a>00056 <span class="comment">// ZIP file structures. Note these have to be packed.</span>
<a name="l00057"></a>00057 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="preprocessor">#pragma pack(1)</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00061"></a>00061 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00062"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html">00062</a> <span class="keyword">struct </span><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html">CZipFile::TZipLocalHeader</a>
<a name="l00063"></a>00063 {
<a name="l00064"></a>00064   <span class="keyword">enum</span>
<a name="l00065"></a>00065   {
<a name="l00066"></a>00066     <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#w1w0">SIGNATURE</a> = 0x04034b50,
<a name="l00067"></a>00067   };
<a name="l00068"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o0">00068</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o0">sig</a>;
<a name="l00069"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o1">00069</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o1">version</a>;
<a name="l00070"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o2">00070</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o2">flag</a>;
<a name="l00071"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o3">00071</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o3">compression</a>;      <span class="comment">// Z_NO_COMPRESSION or Z_DEFLATED</span>
<a name="l00072"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o4">00072</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o4">modTime</a>;
<a name="l00073"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o5">00073</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o5">modDate</a>;
<a name="l00074"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o6">00074</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o6">crc32</a>;
<a name="l00075"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o7">00075</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o7">cSize</a>;
<a name="l00076"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o8">00076</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o8">ucSize</a>;
<a name="l00077"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o9">00077</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o9">fnameLen</a>;         <span class="comment">// Filename string follows header.</span>
<a name="l00078"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o10">00078</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#o10">xtraLen</a>;          <span class="comment">// Extra field follows filename.</span>
<a name="l00079"></a>00079 };
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00082"></a>00082 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00083"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html">00083</a> <span class="keyword">struct </span><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html">CZipFile::TZipDirHeader</a>
<a name="l00084"></a>00084 {
<a name="l00085"></a>00085   <span class="keyword">enum</span>
<a name="l00086"></a>00086   {
<a name="l00087"></a>00087     SIGNATURE = 0x06054b50
<a name="l00088"></a>00088   };
<a name="l00089"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html#o0">00089</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   sig;
<a name="l00090"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html#o1">00090</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    nDisk;
<a name="l00091"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html#o2">00091</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    nStartDisk;
<a name="l00092"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html#o3">00092</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    nDirEntries;
<a name="l00093"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html#o4">00093</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    totalDirEntries;
<a name="l00094"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html#o5">00094</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   dirSize;
<a name="l00095"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html#o6">00095</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   dirOffset;
<a name="l00096"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html#o7">00096</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    cmntLen;
<a name="l00097"></a>00097 };
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00100"></a>00100 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00101"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html">00101</a> <span class="keyword">struct </span><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html">CZipFile::TZipDirFileHeader</a>
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103   <span class="keyword">enum</span>
<a name="l00104"></a>00104   {
<a name="l00105"></a>00105     SIGNATURE   = 0x02014b50
<a name="l00106"></a>00106   };
<a name="l00107"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o0">00107</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   sig;
<a name="l00108"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o1">00108</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    verMade;
<a name="l00109"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o2">00109</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    verNeeded;
<a name="l00110"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o3">00110</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    flag;
<a name="l00111"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o4">00111</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    compression;      <span class="comment">// COMP_xxxx</span>
<a name="l00112"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o5">00112</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    modTime;
<a name="l00113"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o6">00113</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    modDate;
<a name="l00114"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o7">00114</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   crc32;
<a name="l00115"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o8">00115</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   cSize;            <span class="comment">// Compressed size</span>
<a name="l00116"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o9">00116</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   ucSize;           <span class="comment">// Uncompressed size</span>
<a name="l00117"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o10">00117</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    fnameLen;         <span class="comment">// Filename string follows header.</span>
<a name="l00118"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o11">00118</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    xtraLen;          <span class="comment">// Extra field follows filename.</span>
<a name="l00119"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o12">00119</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    cmntLen;          <span class="comment">// Comment field follows extra field.</span>
<a name="l00120"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o13">00120</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    diskStart;
<a name="l00121"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o14">00121</a>   <a class="code" href="_zip_file_8cpp.html#a1">word</a>    intAttr;
<a name="l00122"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o15">00122</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   extAttr;
<a name="l00123"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o16">00123</a>   <a class="code" href="_zip_file_8cpp.html#a0">dword</a>   hdrOffset;
<a name="l00124"></a>00124 
<a name="l00125"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#a0">00125</a>   <span class="keywordtype">char</span> *GetName   ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">char</span> *)(<span class="keyword">this</span> + 1);   }
<a name="l00126"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#a1">00126</a>   <span class="keywordtype">char</span> *GetExtra  ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> GetName() + fnameLen; }
<a name="l00127"></a><a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#a2">00127</a>   <span class="keywordtype">char</span> *GetComment()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> GetExtra() + xtraLen; }
<a name="l00128"></a>00128 };
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="preprocessor">#pragma pack()</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>
<a name="l00132"></a>00132 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00133"></a>00133 <span class="comment">// Function:      Init</span>
<a name="l00134"></a>00134 <span class="comment">// Purpose:       Initialize the object and read the zip file directory.</span>
<a name="l00135"></a>00135 <span class="comment">// Parameters:    A stdio FILE* used for reading.</span>
<a name="l00136"></a>00136 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00137"></a><a class="code" href="class_c_zip_file.html#a2">00137</a> <span class="keywordtype">bool</span> <a class="code" href="class_c_zip_file.html#a2">CZipFile::Init</a>(<span class="keyword">const</span> _TCHAR *resFileName)
<a name="l00138"></a>00138 {
<a name="l00139"></a>00139   <a class="code" href="class_c_zip_file.html#a3">End</a>();
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   m_pFile = _wfopen(resFileName, _T(<span class="stringliteral">"rb"</span>));
<a name="l00142"></a>00142   <span class="keywordflow">if</span> (!m_pFile)
<a name="l00143"></a>00143     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="comment">// Assuming no extra comment at the end, read the whole end record.</span>
<a name="l00146"></a>00146   <a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html">TZipDirHeader</a> dh;
<a name="l00147"></a>00147 
<a name="l00148"></a>00148   fseek(m_pFile, -(<span class="keywordtype">int</span>)<span class="keyword">sizeof</span>(dh), <a class="code" href="zconf_8h.html#a6">SEEK_END</a>);
<a name="l00149"></a>00149   <span class="keywordtype">long</span> dhOffset = ftell(m_pFile);
<a name="l00150"></a>00150   memset(&amp;dh, 0, <span class="keyword">sizeof</span>(dh));
<a name="l00151"></a>00151   fread(&amp;dh, <span class="keyword">sizeof</span>(dh), 1, m_pFile);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153   <span class="comment">// Check</span>
<a name="l00154"></a>00154   <span class="keywordflow">if</span> (dh.sig != <a class="code" href="struct_c_zip_file_1_1_t_zip_dir_header.html#w1w0">TZipDirHeader::SIGNATURE</a>)
<a name="l00155"></a>00155     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <span class="comment">// Go to the beginning of the directory.</span>
<a name="l00158"></a>00158   fseek(m_pFile, dhOffset - dh.dirSize, <a class="code" href="zconf_8h.html#a4">SEEK_SET</a>);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   <span class="comment">// Allocate the data buffer, and read the whole thing.</span>
<a name="l00161"></a>00161   m_pDirData = <a class="code" href="_game_code_std_8h.html#a2">GCC_NEW</a> <span class="keywordtype">char</span>[dh.dirSize + dh.nDirEntries*<span class="keyword">sizeof</span>(*m_papDir)];
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (!m_pDirData)
<a name="l00163"></a>00163     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00164"></a>00164   memset(m_pDirData, 0, dh.dirSize + dh.nDirEntries*<span class="keyword">sizeof</span>(*m_papDir));
<a name="l00165"></a>00165   fread(m_pDirData, dh.dirSize, 1, m_pFile);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <span class="comment">// Now process each entry.</span>
<a name="l00168"></a>00168   <span class="keywordtype">char</span> *pfh = m_pDirData;
<a name="l00169"></a>00169   m_papDir = (<span class="keyword">const</span> <a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html">TZipDirFileHeader</a> **)(m_pDirData + dh.dirSize);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dh.nDirEntries &amp;&amp; success; i++)
<a name="l00174"></a>00174   {
<a name="l00175"></a>00175     <a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html">TZipDirFileHeader</a> &amp;fh = *(<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html">TZipDirFileHeader</a>*)pfh;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     <span class="comment">// Store the address of nth file for quicker access.</span>
<a name="l00178"></a>00178     m_papDir[i] = &amp;fh;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     <span class="comment">// Check the directory entry integrity.</span>
<a name="l00181"></a>00181     <span class="keywordflow">if</span> (fh.<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o0">sig</a> != <a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#w1w0">TZipDirFileHeader::SIGNATURE</a>)
<a name="l00182"></a>00182       success = <span class="keyword">false</span>;
<a name="l00183"></a>00183     <span class="keywordflow">else</span>
<a name="l00184"></a>00184     {
<a name="l00185"></a>00185       pfh += <span class="keyword">sizeof</span>(fh);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187       <span class="comment">// Convert UNIX slashes to DOS backlashes.</span>
<a name="l00188"></a>00188       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; fh.<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o10">fnameLen</a>; j++)
<a name="l00189"></a>00189         <span class="keywordflow">if</span> (pfh[j] == <span class="charliteral">'/'</span>)
<a name="l00190"></a>00190           pfh[j] = <span class="charliteral">'\\'</span>;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192           <span class="keywordtype">char</span> fileName[_MAX_PATH];
<a name="l00193"></a>00193           memcpy(fileName, pfh, fh.<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o10">fnameLen</a>);
<a name="l00194"></a>00194           fileName[fh.<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o10">fnameLen</a>]=0;
<a name="l00195"></a>00195           _strlwr(fileName);
<a name="l00196"></a>00196           std::string spath = fileName;
<a name="l00197"></a>00197           <a class="code" href="class_c_zip_file.html#o0">m_ZipContentsMap</a>[spath] = i;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199       <span class="comment">// Skip name, extra and comment fields.</span>
<a name="l00200"></a>00200       pfh += fh.<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o10">fnameLen</a> + fh.<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o11">xtraLen</a> + fh.<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o12">cmntLen</a>;
<a name="l00201"></a>00201     }
<a name="l00202"></a>00202   }
<a name="l00203"></a>00203   <span class="keywordflow">if</span> (!success)
<a name="l00204"></a>00204   {
<a name="l00205"></a>00205     <a class="code" href="dxstdafx_8h.html#a8">SAFE_DELETE_ARRAY</a>(m_pDirData);
<a name="l00206"></a>00206   }
<a name="l00207"></a>00207   <span class="keywordflow">else</span>
<a name="l00208"></a>00208   {
<a name="l00209"></a>00209     m_nEntries = dh.nDirEntries;
<a name="l00210"></a>00210   }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="keywordflow">return</span> success;
<a name="l00213"></a>00213 }
<a name="l00214"></a>00214 
<a name="l00215"></a><a class="code" href="class_c_zip_file.html#a8">00215</a> <a class="code" href="classoptional.html">optional&lt;int&gt;</a> <a class="code" href="class_c_zip_file.html#a8">CZipFile::Find</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)<span class="keyword"> const</span>
<a name="l00216"></a>00216 <span class="keyword"></span>{
<a name="l00217"></a>00217         <span class="keywordtype">char</span> lwrPath[_MAX_PATH];
<a name="l00218"></a>00218         strcpy(lwrPath, path);
<a name="l00219"></a>00219         _strlwr(lwrPath);
<a name="l00220"></a>00220         ZipContentsMap::const_iterator i = <a class="code" href="class_c_zip_file.html#o0">m_ZipContentsMap</a>.find(lwrPath);
<a name="l00221"></a>00221         <span class="keywordflow">if</span> (i==<a class="code" href="class_c_zip_file.html#o0">m_ZipContentsMap</a>.end())
<a name="l00222"></a>00222                 <span class="keywordflow">return</span> <a class="code" href="classoptional__empty.html">optional_empty</a>();
<a name="l00223"></a>00223 
<a name="l00224"></a>00224         <span class="keywordflow">return</span> (*i).second;
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00230"></a>00230 <span class="comment">// Function:      End</span>
<a name="l00231"></a>00231 <span class="comment">// Purpose:       Finish the object</span>
<a name="l00232"></a>00232 <span class="comment">// Parameters:    </span>
<a name="l00233"></a>00233 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00234"></a><a class="code" href="class_c_zip_file.html#a3">00234</a> <span class="keywordtype">void</span> <a class="code" href="class_c_zip_file.html#a3">CZipFile::End</a>()
<a name="l00235"></a>00235 {
<a name="l00236"></a>00236         <a class="code" href="class_c_zip_file.html#o0">m_ZipContentsMap</a>.empty();
<a name="l00237"></a>00237     <a class="code" href="dxstdafx_8h.html#a8">SAFE_DELETE_ARRAY</a>(m_pDirData);
<a name="l00238"></a>00238     m_nEntries = 0;
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00242"></a>00242 <span class="comment">// Function:      GetFilename</span>
<a name="l00243"></a>00243 <span class="comment">// Purpose:       Return the name of a file</span>
<a name="l00244"></a>00244 <span class="comment">// Parameters:    The file index and the buffer where to store the filename</span>
<a name="l00245"></a>00245 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00246"></a><a class="code" href="class_c_zip_file.html#a5">00246</a> <span class="keywordtype">void</span> <a class="code" href="class_c_zip_file.html#a5">CZipFile::GetFilename</a>(<span class="keywordtype">int</span> i, <span class="keywordtype">char</span> *pszDest)<span class="keyword">  const</span>
<a name="l00247"></a>00247 <span class="keyword"></span>{
<a name="l00248"></a>00248   <span class="keywordflow">if</span> (pszDest != NULL)
<a name="l00249"></a>00249   {
<a name="l00250"></a>00250     <span class="keywordflow">if</span> (i &lt; 0 || i &gt;= m_nEntries)
<a name="l00251"></a>00251       *pszDest = <span class="charliteral">'\0'</span>;
<a name="l00252"></a>00252     <span class="keywordflow">else</span>
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254       memcpy(pszDest, m_papDir[i]-&gt;GetName(), m_papDir[i]-&gt;fnameLen);
<a name="l00255"></a>00255       pszDest[m_papDir[i]-&gt;<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o10">fnameLen</a>] = <span class="charliteral">'\0'</span>;
<a name="l00256"></a>00256     }
<a name="l00257"></a>00257   }
<a name="l00258"></a>00258 }
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00262"></a>00262 <span class="comment">// Function:      GetFileLen</span>
<a name="l00263"></a>00263 <span class="comment">// Purpose:       Return the length of a file so a buffer can be allocated</span>
<a name="l00264"></a>00264 <span class="comment">// Parameters:    The file index.</span>
<a name="l00265"></a>00265 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00266"></a><a class="code" href="class_c_zip_file.html#a6">00266</a> <span class="keywordtype">int</span> <a class="code" href="class_c_zip_file.html#a6">CZipFile::GetFileLen</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00267"></a>00267 <span class="keyword"></span>{
<a name="l00268"></a>00268   <span class="keywordflow">if</span> (i &lt; 0 || i &gt;= m_nEntries)
<a name="l00269"></a>00269     <span class="keywordflow">return</span> -1;
<a name="l00270"></a>00270   <span class="keywordflow">else</span>
<a name="l00271"></a>00271     <span class="keywordflow">return</span> m_papDir[i]-&gt;<a class="code" href="struct_c_zip_file_1_1_t_zip_dir_file_header.html#o9">ucSize</a>;
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00275"></a>00275 <span class="comment">// Function:      ReadFile</span>
<a name="l00276"></a>00276 <span class="comment">// Purpose:       Uncompress a complete file</span>
<a name="l00277"></a>00277 <span class="comment">// Parameters:    The file index and the pre-allocated buffer</span>
<a name="l00278"></a>00278 <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l00279"></a><a class="code" href="class_c_zip_file.html#a7">00279</a> <span class="keywordtype">bool</span> <a class="code" href="class_c_zip_file.html#a7">CZipFile::ReadFile</a>(<span class="keywordtype">int</span> i, <span class="keywordtype">void</span> *pBuf)
<a name="l00280"></a>00280 {
<a name="l00281"></a>00281   <span class="keywordflow">if</span> (pBuf == NULL || i &lt; 0 || i &gt;= m_nEntries)
<a name="l00282"></a>00282     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <span class="comment">// Quick'n dirty read, the whole file at once.</span>
<a name="l00285"></a>00285   <span class="comment">// Ungood if the ZIP has huge files inside</span>
<a name="l00286"></a>00286 
<a name="l00287"></a>00287   <span class="comment">// Go to the actual file and read the local header.</span>
<a name="l00288"></a>00288   fseek(m_pFile, m_papDir[i]-&gt;hdrOffset, <a class="code" href="zconf_8h.html#a4">SEEK_SET</a>);
<a name="l00289"></a>00289   <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html">TZipLocalHeader</a> h;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291   memset(&amp;h, 0, <span class="keyword">sizeof</span>(h));
<a name="l00292"></a>00292   fread(&amp;h, <span class="keyword">sizeof</span>(h), 1, m_pFile);
<a name="l00293"></a>00293   <span class="keywordflow">if</span> (h.sig != <a class="code" href="struct_c_zip_file_1_1_t_zip_local_header.html#w1w0">TZipLocalHeader::SIGNATURE</a>)
<a name="l00294"></a>00294     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296   <span class="comment">// Skip extra fields</span>
<a name="l00297"></a>00297   fseek(m_pFile, h.fnameLen + h.xtraLen, <a class="code" href="zconf_8h.html#a5">SEEK_CUR</a>);
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <span class="keywordflow">if</span> (h.compression == <a class="code" href="zlib_8h.html#a15">Z_NO_COMPRESSION</a>)
<a name="l00300"></a>00300   {
<a name="l00301"></a>00301     <span class="comment">// Simply read in raw stored data.</span>
<a name="l00302"></a>00302     fread(pBuf, h.cSize, 1, m_pFile);
<a name="l00303"></a>00303     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00304"></a>00304   }
<a name="l00305"></a>00305   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (h.compression != <a class="code" href="zlib_8h.html#a25">Z_DEFLATED</a>)
<a name="l00306"></a>00306     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="comment">// Alloc compressed data buffer and read the whole stream</span>
<a name="l00309"></a>00309   <span class="keywordtype">char</span> *pcData = <a class="code" href="_game_code_std_8h.html#a2">GCC_NEW</a> <span class="keywordtype">char</span>[h.cSize];
<a name="l00310"></a>00310   <span class="keywordflow">if</span> (!pcData)
<a name="l00311"></a>00311     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   memset(pcData, 0, h.cSize);
<a name="l00314"></a>00314   fread(pcData, h.cSize, 1, m_pFile);
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="keywordtype">bool</span> ret = <span class="keyword">true</span>;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318   <span class="comment">// Setup the inflate stream.</span>
<a name="l00319"></a>00319   <a class="code" href="structz__stream__s.html">z_stream</a> <a class="code" href="ioapi_8h.html#a17">stream</a>;
<a name="l00320"></a>00320   <span class="keywordtype">int</span> err;
<a name="l00321"></a>00321 
<a name="l00322"></a>00322   stream.<a class="code" href="structz__stream__s.html#o0">next_in</a> = (<a class="code" href="zconf_8h.html#a11">Bytef</a>*)pcData;
<a name="l00323"></a>00323   stream.<a class="code" href="structz__stream__s.html#o1">avail_in</a> = (<a class="code" href="zconf_8h.html#a9">uInt</a>)h.cSize;
<a name="l00324"></a>00324   stream.<a class="code" href="structz__stream__s.html#o3">next_out</a> = (<a class="code" href="zconf_8h.html#a11">Bytef</a>*)pBuf;
<a name="l00325"></a>00325   stream.<a class="code" href="structz__stream__s.html#o4">avail_out</a> = h.ucSize;
<a name="l00326"></a>00326   stream.<a class="code" href="structz__stream__s.html#o8">zalloc</a> = (alloc_func)0;
<a name="l00327"></a>00327   stream.<a class="code" href="structz__stream__s.html#o9">zfree</a> = (free_func)0;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329   <span class="comment">// Perform inflation. wbits &lt; 0 indicates no zlib header inside the data.</span>
<a name="l00330"></a>00330   err = <a class="code" href="zlib_8h.html#a30">inflateInit2</a>(&amp;stream, -<a class="code" href="zconf_8h.html#a1">MAX_WBITS</a>);
<a name="l00331"></a>00331   <span class="keywordflow">if</span> (err == <a class="code" href="zlib_8h.html#a6">Z_OK</a>)
<a name="l00332"></a>00332   {
<a name="l00333"></a>00333     err = inflate(&amp;stream, <a class="code" href="zlib_8h.html#a5">Z_FINISH</a>);
<a name="l00334"></a>00334     inflateEnd(&amp;stream);
<a name="l00335"></a>00335     <span class="keywordflow">if</span> (err == <a class="code" href="zlib_8h.html#a7">Z_STREAM_END</a>)
<a name="l00336"></a>00336       err = <a class="code" href="zlib_8h.html#a6">Z_OK</a>;
<a name="l00337"></a>00337     inflateEnd(&amp;stream);
<a name="l00338"></a>00338   }
<a name="l00339"></a>00339   <span class="keywordflow">if</span> (err != <a class="code" href="zlib_8h.html#a6">Z_OK</a>)
<a name="l00340"></a>00340     ret = <span class="keyword">false</span>;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342   <span class="keyword">delete</span>[] pcData;
<a name="l00343"></a>00343   <span class="keywordflow">return</span> ret;
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 <span class="comment">/*******************************************************</span>
<a name="l00349"></a>00349 <span class="comment">Example useage:</span>
<a name="l00350"></a>00350 <span class="comment"></span>
<a name="l00351"></a>00351 <span class="comment">void MakePath(const char *pszPath)</span>
<a name="l00352"></a>00352 <span class="comment">{</span>
<a name="l00353"></a>00353 <span class="comment">  if (pszPath[0] == '\0')</span>
<a name="l00354"></a>00354 <span class="comment">    return;</span>
<a name="l00355"></a>00355 <span class="comment"></span>
<a name="l00356"></a>00356 <span class="comment">  char buf[1000];</span>
<a name="l00357"></a>00357 <span class="comment">  const char *p = pszPath;</span>
<a name="l00358"></a>00358 <span class="comment"></span>
<a name="l00359"></a>00359 <span class="comment">//  printf("MakePath(\"%s\")\n", pszPath);</span>
<a name="l00360"></a>00360 <span class="comment"></span>
<a name="l00361"></a>00361 <span class="comment">  // Skip machine name in network paths like \\MyMachine\blah...</span>
<a name="l00362"></a>00362 <span class="comment">  if (p[0] == '\\' &amp;&amp; p[1] == '\\')</span>
<a name="l00363"></a>00363 <span class="comment">    p = strchr(p+2, '\\');</span>
<a name="l00364"></a>00364 <span class="comment"></span>
<a name="l00365"></a>00365 <span class="comment">  while (p != NULL &amp;&amp; *p != '\0')</span>
<a name="l00366"></a>00366 <span class="comment">  {</span>
<a name="l00367"></a>00367 <span class="comment">    p = strchr(p, '\\');</span>
<a name="l00368"></a>00368 <span class="comment"></span>
<a name="l00369"></a>00369 <span class="comment">    if (p)</span>
<a name="l00370"></a>00370 <span class="comment">    {</span>
<a name="l00371"></a>00371 <span class="comment">      memcpy(buf, pszPath, p - pszPath);</span>
<a name="l00372"></a>00372 <span class="comment">      buf[p - pszPath] = 0;</span>
<a name="l00373"></a>00373 <span class="comment">      p++;</span>
<a name="l00374"></a>00374 <span class="comment">    }</span>
<a name="l00375"></a>00375 <span class="comment">    else</span>
<a name="l00376"></a>00376 <span class="comment">      strcpy(buf, pszPath);</span>
<a name="l00377"></a>00377 <span class="comment"></span>
<a name="l00378"></a>00378 <span class="comment">    if (buf[0] != '\0' &amp;&amp; strcmp(buf, ".") &amp;&amp; strcmp(buf, ".."))</span>
<a name="l00379"></a>00379 <span class="comment">    {</span>
<a name="l00380"></a>00380 <span class="comment">//      printf("  Making path: \"%s\"\n", buf);</span>
<a name="l00381"></a>00381 <span class="comment">      mkdir(buf);</span>
<a name="l00382"></a>00382 <span class="comment">    }</span>
<a name="l00383"></a>00383 <span class="comment">  }</span>
<a name="l00384"></a>00384 <span class="comment">}</span>
<a name="l00385"></a>00385 <span class="comment"></span>
<a name="l00386"></a>00386 <span class="comment"></span>
<a name="l00387"></a>00387 <span class="comment"></span>
<a name="l00388"></a>00388 <span class="comment">void main(int argc, const char *argv[])</span>
<a name="l00389"></a>00389 <span class="comment">{</span>
<a name="l00390"></a>00390 <span class="comment">  if (argc &gt; 1)</span>
<a name="l00391"></a>00391 <span class="comment">  {</span>
<a name="l00392"></a>00392 <span class="comment">    FILE *f = fopen(argv[1], "rb");</span>
<a name="l00393"></a>00393 <span class="comment">    if (f)</span>
<a name="l00394"></a>00394 <span class="comment">    {</span>
<a name="l00395"></a>00395 <span class="comment">      CZipFile zip;</span>
<a name="l00396"></a>00396 <span class="comment"></span>
<a name="l00397"></a>00397 <span class="comment">      if (true != zip.Init(f))</span>
<a name="l00398"></a>00398 <span class="comment">        printf("Bad Zip file: \"%s\"\n", argv[1]);</span>
<a name="l00399"></a>00399 <span class="comment">      else</span>
<a name="l00400"></a>00400 <span class="comment">      {</span>
<a name="l00401"></a>00401 <span class="comment">        for (int i = 0; i &lt; zip.GetNumFiles(); i++)</span>
<a name="l00402"></a>00402 <span class="comment">        {</span>
<a name="l00403"></a>00403 <span class="comment">          int len = zip.GetFileLen(i);</span>
<a name="l00404"></a>00404 <span class="comment">          char fname[1000];</span>
<a name="l00405"></a>00405 <span class="comment"></span>
<a name="l00406"></a>00406 <span class="comment">          zip.GetFilename(i, fname);</span>
<a name="l00407"></a>00407 <span class="comment"></span>
<a name="l00408"></a>00408 <span class="comment">          printf("File \"%s\" (%d bytes): ", fname, len);</span>
<a name="l00409"></a>00409 <span class="comment"></span>
<a name="l00410"></a>00410 <span class="comment">          char *pData = new char[len];</span>
<a name="l00411"></a>00411 <span class="comment">          if (!pData)</span>
<a name="l00412"></a>00412 <span class="comment">            printf("OUT OF MEMORY\n");</span>
<a name="l00413"></a>00413 <span class="comment">          else if (true == zip.ReadFile(i, pData))</span>
<a name="l00414"></a>00414 <span class="comment">          {</span>
<a name="l00415"></a>00415 <span class="comment">            printf("OK\n");</span>
<a name="l00416"></a>00416 <span class="comment">            char dpath[1000];</span>
<a name="l00417"></a>00417 <span class="comment"></span>
<a name="l00418"></a>00418 <span class="comment">            sprintf(dpath, "Data\\%s", fname);</span>
<a name="l00419"></a>00419 <span class="comment">            char *p = strrchr(dpath, '\\');</span>
<a name="l00420"></a>00420 <span class="comment">            if (p)</span>
<a name="l00421"></a>00421 <span class="comment">            {</span>
<a name="l00422"></a>00422 <span class="comment">              *p = '\0';</span>
<a name="l00423"></a>00423 <span class="comment">              MakePath(dpath);</span>
<a name="l00424"></a>00424 <span class="comment">              *p = '\\';</span>
<a name="l00425"></a>00425 <span class="comment">            }</span>
<a name="l00426"></a>00426 <span class="comment">            FILE *fo = fopen(dpath, "wb");</span>
<a name="l00427"></a>00427 <span class="comment">            if (fo)</span>
<a name="l00428"></a>00428 <span class="comment">            {</span>
<a name="l00429"></a>00429 <span class="comment">              fwrite(pData, len, 1, fo);</span>
<a name="l00430"></a>00430 <span class="comment">              fclose(fo);</span>
<a name="l00431"></a>00431 <span class="comment">            }</span>
<a name="l00432"></a>00432 <span class="comment">          }</span>
<a name="l00433"></a>00433 <span class="comment">          else</span>
<a name="l00434"></a>00434 <span class="comment">            printf("ERROR\n");</span>
<a name="l00435"></a>00435 <span class="comment">          delete[] pData;</span>
<a name="l00436"></a>00436 <span class="comment">        }</span>
<a name="l00437"></a>00437 <span class="comment">        zip.End();</span>
<a name="l00438"></a>00438 <span class="comment">      }</span>
<a name="l00439"></a>00439 <span class="comment"></span>
<a name="l00440"></a>00440 <span class="comment">      fclose(f);</span>
<a name="l00441"></a>00441 <span class="comment">    }</span>
<a name="l00442"></a>00442 <span class="comment">  }</span>
<a name="l00443"></a>00443 <span class="comment">}</span>
<a name="l00444"></a>00444 <span class="comment">******************************************************/</span>
<a name="l00445"></a>00445 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Aug 22 14:08:19 2006 for GameCode by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.3 </small></address>
</body>
</html>
